# Task ID: 44
# Title: Create DurationTrackerUseCase to Eliminate Coroutine Management from ViewModel
# Status: pending
# Dependencies: 10, 39, 6
# Priority: medium
# Description: Remove the coroutine and delay management from AudioRecordingViewModel by creating a DurationTrackerUseCase that emits Flow<Long> for recording duration, moving timing logic to proper domain layer architecture.
# Details:
CRITICAL ARCHITECTURE VIOLATION: AudioRecordingViewModel directly manages coroutines and delays (lines 120-128) with startDurationTimer() method containing a while loop with kotlinx.coroutines.delay(100). This violates clean architecture - ViewModels must ONLY collect flows, not manage timing infrastructure.

Implementation Steps:
1. Create DurationTrackerUseCase in shared/src/commonMain/kotlin/.../domain/usecases/ that observes AudioRepository.recordingState flow
2. Map RecordingState.Recording(duration) to emit duration values as Flow<Long>, emit 0L for non-recording states
3. Add proper error handling and ensure flow completes when recording stops
4. Remove startDurationTimer() method entirely from AudioRecordingViewModel (lines 120-128)
5. Remove _recordingDuration StateFlow management from ViewModel - duration will come from use case
6. Update observeServiceEvents() method to collect from DurationTrackerUseCase.execute() instead of manual timer
7. Inject DurationTrackerUseCase into AudioRecordingViewModel constructor
8. Register DurationTrackerUseCase in Koin dependency injection modules
9. Update recordingDuration StateFlow to collect from use case flow instead of manual updates
10. Ensure existing UI duration display continues working through proper flow-based architecture
11. Remove all direct audioServiceManager.getRecordingDuration() calls from ViewModel
12. The egregious while loop with delay(100) will be completely eliminated, replaced with clean reactive flow architecture

# Test Strategy:
1. Verify DurationTrackerUseCase emits correct duration values during recording states and 0L when idle. 2. Test duration updates every 100ms through flow emissions without ViewModel managing any timers. 3. Confirm startDurationTimer() method is completely removed from AudioRecordingViewModel. 4. Test recording duration UI updates work correctly through new use case flow. 5. Verify no coroutine management or delay() calls remain in ViewModel. 6. Test that duration resets to 0 when recording stops through use case flow. 7. Run existing AudioRecordingViewModelTest to ensure no regressions in functionality. 8. Test complete recording workflow: start recording → duration updates → stop recording → duration reset. 9. Verify memory and performance - no timer leaks when ViewModel is destroyed.
